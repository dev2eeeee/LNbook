[role="pagenumrestart"]
[[intro_what_is_the_lightning_network]]
== Introduction

_마스터링 라이트닝 네트워크_에 오신 것을 환영합니다!

((("Lightning Network (generally)", seealso="innovations in Lightning", id="ix_01_introduction-asciidoc0", range="startofrange")))라이트닝 네트워크(줄여서 LN)는, 사람들이 온라인에서 가치를 교환하는 방식을 바꾸고 있고, 비트코인 역사상 가장 흥미로운 발전 중 하나입니다. 
오늘날, 2021년에, 라이트닝 네트워크는 여전히 초기 단계입니다. 라이트닝 네트워크는 똑똑하고, 독창적인 방법으로 비트코인을 사용하는 프로토콜입니다. 비트코인 위의 레이어 2 기술이죠.

라이트닝 네트워크의 개념은 2015년에 제안되었고, 첫 구현은 2018년에 시작되었습니다. 2021년 현재, 우리는 더 나은 개인 정보 보호, 속도, 규모에서 라이트닝 네트워크가 비트코인에 제공하는 기회를 보기 시작했습니다. 
라이트닝 네트워크의 핵심 개념과 함께, 여러분은 스스로를 위한 기회를 창출하고, 네트워크의 미래를 만드는 데 기여할 수 있습니다.

우리는 여러분이 비트코인에 대한 기초 지식을 이미 갖고 있다고 가정합니다. 그러지 않다면 걱정하지 마세요. 우리는 <<bitcoin_fundamentals_review>>에서, 여러분이 라이트닝 네트워크를 이해하기 위해 반드시 알아야하는, 핵심 비트코인 용어들을 설명할 것입니다. 비트코인에 대해 더 자세히 배우고 싶다면, 안드레아스 M. 안토노폴로스의 _비트코인, 공개 블록체인 프로그래밍_ 2판(O'Reilly, 한글 번역본)을 읽으셔도 됩니다. 영문판은 https://github.com/bitcoinbook/bitcoinbook 에서 무료로 이용 가능합니다.

이 책의 대부분은 프로그래머들을 위해 작성되었지만, 초기 몇몇 챕터들은 프로그래머가 아니어도 누구나 이해하실 수 있도록 작성되었습니다. 이번 챕터에서, 우리는 몇 가지 용어로 시작하여, 신뢰 개념과 이러한 시스템의 적용에 대해 알아본 뒤, 마지막으로 라이트닝 네트워크의 역사와 미래를 얘기해보겠습니다. 그럼 시작하겠습니다.

=== 라이트닝 네트워크 기본 개념들

((("Lightning Network (generally)","basic concepts", id="ix_01_introduction-asciidoc1", range="startofrange")))라이트닝 네트워크가 어떻게 동작하는지 살펴볼 때, 헷갈릴 법한 몇 가지 기술 용어들을 만날 것입니다. 모든 개념과 용어들은 책과 용어집에 자세히 설명되어 있지만, 몇몇 기초 정의를 알면 다음 두 챕터의 내용을 더 쉽게 이해하실 수 있습니다. 아래에서 설명하는 모든 단어들을 이해하지 못해도, 괜찮습니다. 글을 읽을수록 더 많은 것을 이해하실 겁니다.

블록체인:: ((("blockchain","defined")))컴퓨터들의 네트워크가 만들어 낸 분산 거래 원장입니다. 예를 들어, 비트코인은 블록체인을 만드는 시스템입니다. 라이트닝 네트워크 자체는 블록체인도 아니고, 블록체인을 만드는 것도 아닙니다. 보안을 위해, 기존 외부 블록체인에 의존하는 네트워크입니다.

디지털 서명:: ((("digital signatures")))디지털 서명은, 디지털 메시지나 문서의 진위를 확인하기 위한 수학적 기법입니다. 유효한 디지털 서명은, 알려진 발신자가 메시지를 만들었고, 발신자가 메시지를 보냈다는 것을 부정할 수 없고, 메시지가 전송 중 변경되지 않았다고 믿을만한 근거를 수신자에게 제공합니다.

해쉬 함수:: ((("hash function, defined")))암호 해쉬 함수는, 데이터가 어떤 크기를 갖더라도, 고정된 크기의 문자열로 대응시켜주는 수학적 알고리즘입니다. 결과값을 통해 입력값을 계산하는 역연산은 불가능한, 단방향 함수입니다.

노드:: ((("node, defined")))네트워크에 참여하는 컴퓨터를 말합니다. 라이트닝 노드는 라이트닝 네트워크에 참여하는 컴퓨터입니다. 비트코인 노드는 비트코인 네트워크에 참여하는 컴퓨터입니다. 보통 라이트닝 네트워크 사용자는 라이트닝 노드와 비트코인 노드를 _동시에_ 실행시킬 것입니다.

온체인 vs 오프체인:: ((("on-chain payment","defined")))비트코인이나 다른 블록체인 상에서 트랜잭션으로 기록되면, _온체인_ 지불입니다. ((("off-chain payment")))블록체인 상에서는 보이지 않고, 라이트닝 노드들 간 지불 채널을 통한 전송은 _오프체인_ 지불입니다. 일반적으로 라이트닝 네트워크에서, 라이트닝 지불 채널을 열고 닫을 때가 유일한 온체인 트랜잭션입니다. 다른 온체인 트랜잭션 유형으로는, 스플라이싱(splicing)이라고 하는 채널 수정 트랜잭션이 있습니다. 스플라이싱은 채널 내에 맡긴 자금의 양을 수정할 때 사용됩니다.

지불:: ((("payment","defined")))비트코인의 ”트랜잭션”처럼, 라이트닝 네트워크에서 가치가 교환되는 것을 “지불”이라고 부릅니다.

지불 채널:: ((("payment channel", seealso="channel entries")))지불 채널은 라이트닝 네트워크에서 두 노드 간의 _재정적 관계_를 뜻합니다. 보통 두 라이트닝 노드들 간의 비트코인 제어권을 공유하는, 비트코인 다중서명 트랜잭션에 의해 구현됩니다.

전달 versus 전송:: ((("routing","sending versus")))((("sending, routing versus")))비트코인에서는 모든 사람에게 브로드캐스트하여 트랜잭션을 “전송”합니다. 그러나 라이트닝 네트워크는 송신자와 수신자 간 _경로_를 따르는 하나 이상의 지불 채널을 통해, 지불이 “전달”되는 전달 네트워크(routed network)를 이용합니다. 

트랜잭션:: ((("transaction, defined")))비트코인과 같은 자금의 소유권 이동을 기록하는 데이터 구조입니다. 라이트닝 네트워크는 자금의 소유권을 추적하기 위해 비트코인 트랜잭션(혹은 다른 블록체인의 트랜잭션)에 의존합니다.

더 상세하고 다양한 정의들은 <<gloassary>>에서 찾을 수 있습니다. 이 책 전반에서, 우리는 이 용어들이 무엇을 의미하는지, 어떻게 이 기술이 실제로 동작하는지 설명할 것입니다.

[TIP]
====
책에서 “비트코인”은 비트코인 시스템 자체를 의미하는 고유명사로 사용될 수도 있고, 화폐 단위를 의미할 수도 있습니다. 화폐 단위로서 각 비트코인은 1억 단위로 세분화되어 사토시로 불립니다(1 비트코인 = 1억 사토시). (((range="endofrange", startref="ix_01_introduction-asciidoc1")))
====

위 기초 용어들에 익숙해졌다면, 여러분들이 이미 알고 계시는 개념인, 신뢰(trust) 개념에 대해 설명하겠습니다.

=== 탈중앙화 네트워크에서 신뢰(Trust)

((("Lightning Network (generally)","trust in decentralized networks")))((("trustless systems","trust in decentralized networks")))여러분들은 종종 사람들이 비트코인과 라이트닝 네트워크를 “신뢰할 수 없다”고 말하는 것을 들었을 것입니다. 이것을 처음 접하면 혼란스러우실 수 있습니다. 결국, 신뢰는 좋은 것 아닐까요? 심지어 은행에선 이름에 신뢰를 붙이기도 하니까요. “신뢰할 수 없는” 시스템, 신뢰 없는 시스템은 나쁜 것 아닐까요? 

“신뢰할 수 없음(trustless)”의 의미는, 시스템에 참여하는 사람들끼리 서로 신뢰하지 않아도, 시스템이 동작한다는 것을 의미합니다. 비트코인 같은 탈중앙화 시스템에서, 여러분은 항상 여러분이 신뢰하는 사람들끼리만 거래할 수도 있습니다. 그러나 시스템은 여러분들이 신뢰하지 않는 사람과 거래해도, 사기당하지 않는다는 점을 보장해줍니다. 시스템에서 신뢰는 있으면 좋을 뿐이지, 반드시 있어야 하는 것은 아닙니다. 

여러분들이 돈을 맡기고 신뢰하는, 은행과 같은 전통적인 시스템과 비교해보세요. 만약 은행이 여러분들의 신뢰를 깨는 행위를 저질렀다면, 규제 기관이나 법원으로부터 돈 일부를 되찾을 수도 있습니다. 그러나 엄청난 시간, 돈과 노력이 들겠죠.

신뢰할 수 없음(trustless)은 신뢰가 없다는 것을 의미하지 않습니다. 시스템이 부정행위를 방지하기 때문에, 모든 거래에서 신뢰가 전제조건이 될 필요가 없다는 점, 여러분들이 신뢰하지 않는 사람들과도 거래가 가능하다는 점을 의미합니다. 

어떻게 라이트닝 네트워크가 동작하는지 알아보기 전에, _공평성 프로토콜(fair protocol)_이라고 부르는 비트코인과 라이트닝 네트워크의 기초 개념을 이해하는 것이 중요합니다. 공평성 프로토콜은, 신뢰하지 않는 서로가 중앙 기관 없이 공평한 결과를 낼 수 있는 방법을 말합니다. 비트코인 같은 탈중앙화 시스템의 핵심이라고 볼 수 있습니다.


=== 중앙 기관 없는 공평성

((("fairness, ensuring")))((("Lightning Network (generally)","fairness without central authority")))사람들이 이익을 위해 경쟁할 때, 협력과 거래를 위한 신뢰를 어떻게 쌓을 수 있을까요? 이 질문에 대한 답은, 경제학, 사회학, 행동심리학, 수학과 같은 과학적이고 인문학적 학문의 핵심입니다. 몇몇 학문들은 명성, 공평함, 도덕, 심지어 종교와 같은 "가벼운" 개념들이 답이라고 말합니다. 다른 학문은 참가자들이 자신의 이익을 목적으로 이성적으로 행동한다는 가정 하에, 구체적인 답을 주기도 합니다. 

넓은 의미에서, 이익을 위해 경쟁하는 개인들 간에서 공정한 결과를 보장하는 방법이 몇 가지 있습니다.

신뢰하는 사람들과 거래하기:: 이전 거래, 명성, 가족 관계 등을 바탕으로, 이미 신뢰하는 사람들끼리만 거래합니다. 가족처럼 소규모 단위에서 잘 동작하기 때문에, 협력 행동에서 가장 흔합니다. 그러나 규모가 커지지 않고, (그룹 내) 집단중심주의가 강한 사람의 편견으로부터 고통받습니다.

규칙 정하기:: 기관에서 상호작용을 위한 규칙을 정합니다. 규모적으로는 좀 더 낫지만, 기관이 영향을 미칠 수 있는 범위가 한정적이고, 관습과 전통의 차이로 인해 세계적으로 커질 순 없습니다. 기관이 커질수록 권력이 강해지고, 부패로 이어질 수 있다는 부작용도 있습니다. 

믿을 만한 제3자를 이용하기:: 공평함을 위해 모든 상호작용에 중개자를 두는 것입니다. 중개자의 감시를 위해 “규칙까지 정하면”, 규모를 더 확장시킬 수 있지만, 권력의 문제를 겪을 수도 있습니다. 중개자의 힘이 매우 강해지고, 부패로 이어질 수 있습니다. 권력의 집중은 시스템의 위험과 실패로 이어집니다.

게임 이론을 통한 공평성 프로토콜:: 마지막 카테고리는 인터넷과 암호학의 융합으로 비롯되었으며, 이 섹션의 주제입니다. 이것이 어떻게 동작하고, 장단점은 무엇인지 알아봅시다.

==== 중개자 없는 신뢰할 수 있는 프로토콜

((("fairness protocol","trusted protocols without intermediaries")))비트코인과 라이트닝 네트워크 같은 암호화 시스템에서, 여러분들은 신뢰하지 않는 사람들(혹은 컴퓨터)과 거래할 수 있습니다. 이것을 “신뢰할 수 없는(trustless)” 작업이라고 부릅니다. 실제로 신뢰하지 않는 건 아니겠지만요. 여러분들은 실행시키는 소프트웨어를 믿어야 하고, 소프트웨어가 구현하는 프로토콜이 공평한 결과를 만들 것이라고 믿어야 합니다. 

암호화 시스템과는 달리, 전통적인 금융 시스템은 공정한 결과를 보장하기 위해 은행과 같은 _신뢰받는 제3자_가 있어야 합니다. 이때 제3자에게 너무 많은 권력을 줄 수 밖에 없고, _장애 하나(단일 장애점, SPOF)_에도 취약하다는 점이 심각한 문제입니다. 만약 제3자가 신뢰를 위반하거나, 사기를 치려고 한다면, 신뢰는 깨지게 되겠죠.

여러분들이 암호화 시스템을 공부할 때마다, 다음과 같은 특정 패턴을 발견하실 겁니다. 시스템은 제3자에게 의존하는 것 대신에, 유인책과 억제책을 사용하여 불공정한 결과를 방지하려고 시도하는 것 말이죠. 암호화 시스템에서 여러분은 유인책과 억제책을 올바르게 적용할 규칙인 ((("protocol, defined")))_프로토콜_을 신뢰합니다. 프로토콜이 잘 설계되었다는 가정 아래입니다. 이 접근법의 장접은 두 가지 입니다. 여러분이 제 3자를 신뢰하지 않아도 괜찮고, 공정한 결과를 강요할 필요도 없습니다. 참가자들이 합의된 프로토콜을 따르고, 시스템 내에 머무른다면, 프로토콜의 인센티브 정책으로 강제성 없이 공평한 결과를 달성할 것입니다. 


((("game theory")))공평한 결과를 내기 위한 유인책과 억제책의 사용은 _게임 이론_이라고 불리는 수학의 한 분야입니다. 게임 이론에서는 “합리적인 결정을 내리는 사람들 간 전략적 상호 작용 모델”을 연구합니다."footnote:[The Wikipedia https://en.wikipedia.org/wiki/Game_theory[entry on game theory] provides more information.] 비트코인과 라이트닝 네트워크처럼 참가자들 간 재정적 상호작용을 다루는 암호화 시스템에서는, 참가자들 간 사기를 방지하고, 신뢰하지 않는 사람들끼리도 공평한 결과를 내기 위해, 게임 이론에 많이 의존합니다.
 
게임 이론이 무엇이고, 암호화 시스템에서 게임 이론이 어떻게 사용되는지가 처음에는 혼란스럽고 낯선 개념일지도 모릅니다. 그러나 여러분들은 인지하지 못하셨겠지만, 일상생활에서 이미 게임 이론의 상황을 겪고 계실 수도 있습니다. 다음 섹션에서는 어린 시절을 예시로 들어, 게임 이론의 기초 원리를 이해해 볼 것입니다. 기초 원리를 이해하시면 여러분들은 게임 이론을, 블록체인을 다루는 어디에서나 보실 수 있고, 빠르고 직관적으로 이해하실 수 있으실 겁니다. 

((("fairness protocol", id="ix_01_introduction-asciidoc2", range="startofrange")))이 책에서 우리는 이 원리를 ((("fairness protocol","defined")))_공평성 프로토콜_이라고 부릅니다. 유인책과 억제책의 시스템을 사용하여, 서로 신뢰하지 않는 참가자들끼리 공평한 결과를 내도록 보장할 수 있는 프로세스를 의미합니다. 공평성 프로토콜은, 참가자들이 유인책과 억제책을 피할 수 없도록 보장하기 위해 필수입니다.

==== 구체적인 상황 속에서 공평성 프로토콜

((("fairness protocol","real-world example")))여러분들이 이미 친숙한 상황을 예로 들어 공평성 프로토콜을 살펴보도록 하죠.

부모님과 두 아이들이 가족 식사를 하고 있는 상황을 상상해봅시다. 아이들은 까다롭게 먹어요. 감자튀김만 먹으려고 합니다. 부모님들은 감자튀김 한 접시를 준비했습니다. (여러분들의 지역에 따라 감자튀김일 수도, 감자칩일 수도 있습니다.) 아이들은 감자튀김 한 접시를 나눠 먹어야 해요. 부모님은 각 아이들에게 감자튀김을 공정하게 나눠줘야 하는데, 항상 불평을 듣기 일쑤죠(거의 매일요). 공정하지 않는 상황이 매번 발생하면 싸울 수도 있습니다. 부모님들은 어떻게 해야 할까요?

아이들은 이익을 위해 다투면서, 서로 신뢰하지 않습니다. 이때 전략적으로 공평함을 달성할 수 있는 방법이 몇 가지 있습니다. 부모님들께서 흔하게 사용하시는 방법은, 감자튀김을 두 접시에 나눠 담는 방법입니다. 부모님이 신뢰 받는 제3자로서 권한을 사용하는 것이죠. 마치 거래하는 두 사람 간 사기를 방지하기 위해, 은행, 회계사, 변호사처럼 신뢰 받는 제3자가 대신하는 전통적인 금융과 유사합니다. 

이 시나리오의 문제점은 신뢰 받는 제3자에게 너무 많은 권력과 책임을 부여하는 것입니다. 이번 예시에서, 부모님은 전적으로 감자튀김을 동등하게 나눠야 하는 책임이 있습니다. 아이들은 단지 기다리고, 지켜보고, 불평할 뿐이죠. 아이들은 감자튀김을 공평하게 나누지 않고, 편애한다고 비난합니다. 감자튀김을 사이에 두고 상대방 것이 더 크다며, 소리치면서 부모님을 싸움에 끌어들입니다. 끔찍하지 않나요? 부모님들은 더 크게 소리질러야 할까요? 감자튀김을 다 치우면서? 다시는 감자튀김을 안주고, 아이들은 굶어야 한다고 말해야 할까요?

더 나은 해결책이 있습니다. 아이들에게 “나누고 선택하는” 게임을 가르쳐주는 것이죠. 매 점심 식사에서, 한 아이가 감자 튀김을 두 접시에 나누고, _나머지_ 아이가 무엇을 먹을지 선택하는 것입니다. 아이들은 바로 이 게임의 재미를 알아차립니다. 만약 한 아이가 실수하거나, 사기를 치려고 한다면, 다른 아이는 더 큰 접시를 선택해서 상대방을 “벌”할 수 있죠. 공평하게 나누는 것은, 두 아이들 모두에게 가장 큰 이익을 주지만, 특히 두 접시로 나누는 아이에게는 더 이익이 됩니다. 이 시나리오에서는 부정행위를 하는 사람만이 손해입니다. 부모님은 심지어 그들의 권한을 사용할 필요도 없고, 공평함을 강제할 필요도 없습니다. 모든 부모님들은 단지 _규칙을 강제하기만 하면_ 됩니다. 아이들이 “나누고”, “선택하는”, 역할을 피하지 않는 한, 프로토콜 자체로 어떤 간섭도 필요 없이, 공평한 결과를 보장할 수 있습니다. 부모님들은 편애할 수도 없고, 결과를 왜곡할 수도 없습니다.  

[경고]
====
1980년대 악명 높은 감자튀김 배틀을 잘 보여주고 있지만, 실제 저자들과 사촌들 간의 어린 시절 경험이 위 시나리오와 비슷한 것은 완전 우연입니다…그렇겠죠?
====

==== Security Primitives as Building Blocks

((("fairness protocol","security primitives as building blocks")))((("security primitives")))In order for a fairness protocol like this to work, there need to be certain guarantees, or _security primitives_, that can be combined to ensure enforcement. The first security primitive is _strict time ordering/sequencing_: the "splitting" action must happen before the "choosing" action. It's not immediately obvious, but unless you can guarantee that action A happens before action B, then the protocol falls apart. The second security primitive is _commitment with nonrepudiation_. Each sibling must commit to their choice of role: either splitter or chooser. Also, once the splitting has been completed, the splitter is committed to the split they created—they cannot repudiate that choice and go try again.

Cryptographic systems offer a number of security primitives that can be combined in different ways to construct a fairness protocol. In addition to sequencing and commitment, we can also use many other tools:

- Hash functions to fingerprint data, as a form of commitment, or as the basis for a digital signature
- Digital signatures for authentication, nonrepudiation, and proof of ownership of a secret
- Encryption/decryption to restrict access to information to authorized participants only

This is only a small list of a whole "menagerie" of security and cryptographic primitives that are in use. More basic primitives and combinations are invented all the time.

In our real-life example, we saw one form of fairness protocol called "split and choose." This is just one of a myriad different fairness protocols that can be built by combining the building blocks of security primitives in different ways. But the basic pattern is always the same: two or more participants interact without trusting each other by engaging in a series of steps that are part of an agreed protocol. The protocol's steps arrange incentives and disincentives to ensure that if the participants are rational, cheating is counterproductive and fairness is the automatic outcome. Enforcement is not necessary to get fair outcomes—it is only necessary to keep the participants from breaking out of the agreed protocol.

Now that you understand this basic pattern, you will start seeing it everywhere in Bitcoin, the Lightning Network, and many other systems. Let's look at some specific examples next.

==== Example of the Fairness Protocol

((("fairness protocol","Proof of Work example")))((("PoW (Proof of Work) algorithm")))((("Proof of Work (PoW) algorithm")))The most prominent example of a fairness protocol is Bitcoin's consensus algorithm, Proof of Work (PoW). In Bitcoin, miners compete to verify transactions and aggregate them in blocks. To ensure that the miners do not cheat, without entrusting them with authority, Bitcoin uses a system of incentives and disincentives. Miners have to use electricity and dedicate hardware doing "work" that is embedded as a "proof" inside every block. This is achieved because of a property of hash functions where the output value is randomly distributed across the entire range of possible outputs. If miners succeed in producing a valid block fast enough, they are rewarded by earning the block reward for that block. Forcing miners to use a lot of electricity before the network considers their block means that they have an incentive to correctly validate the transactions in the block. If they cheat or make any kind of mistake, their block is rejected and the electricity they used to "prove" it is wasted. No one needs to force miners to produce valid blocks; the reward and punishment incentivize them to do so. All the protocol needs to do is ensure that only valid blocks with Proof of Work are accepted.

The fairness protocol pattern can also be found in many different aspects of the Lightning Network:

* Those who fund channels make sure that they have a refund transaction signed before they publish the funding transaction.

* Whenever a channel is moved to a new state, the old state is "revoked" by ensuring that if anyone tries to broadcast it, they lose the entire balance and get punished.

* Those who forward payments know that if they commit funds forward, they can either get a refund or get paid by the node preceding them.

Again and again, we see this pattern. Fair outcomes are not enforced by any authority. They emerge as the natural consequence of a protocol that rewards fairness and punishes cheating, a fairness protocol that harnesses self-interest by directing it toward fair outcomes.

Bitcoin and the Lightning Network are both implementations of fairness protocols. So why do we need the Lightning Network? Isn't Bitcoin enough?(((range="endofrange", startref="ix_01_introduction-asciidoc2")))


=== Motivation for the Lightning Network

((("Lightning Network (generally)","motivation for", id="ix_01_introduction-asciidoc3", range="startofrange")))Bitcoin is a system that records transactions on a globally replicated public ledger. Every transaction is seen, validated, and stored by every participating computer. As you can imagine, this generates a lot of data and is difficult to scale.

As Bitcoin and the demand for transactions grew, the number of transactions in each block increased until it eventually reached the block size limit.
Once blocks are "full," excess transactions are left to wait in a queue. Many users will increase the fees they're willing to pay to buy space for their transactions in the next block.

If demand continues to outpace the capacity of the network, an increasing number of users' transactions are left waiting unconfirmed. Competition for fees also increases the cost of each transaction, making many smaller-value transactions (e.g., microtransactions) completely uneconomical during periods of particularly high demand.

To solve this problem, we could increase the block size limit to create space for more transactions. An increase in the "supply" of block space will lead to a lower price equilibrium for transaction fees.

However, increasing block size shifts the cost to node operators and requires them to expend more resources to validate and store the blockchain. Because blockchains are gossip protocols, each node is required to know and validate every single transaction that occurs on the network. Furthermore, once validated, each transaction and block must be propagated to the node's "neighbors," multiplying the bandwidth requirements. As such, the greater the block size, the greater the bandwidth, processing, and storage requirements for each individual node. Increasing transaction capacity in this way has the undesirable effect of centralizing the system by reducing the number of nodes and node operators. Since node operators are not compensated for running nodes, if nodes are very expensive to run, only a few well-funded node operators will continue to run nodes.

==== Scaling Blockchains

((("blockchain","scaling", id="ix_01_introduction-asciidoc4", range="startofrange")))((("Lightning Network (generally)","scaling blockchains", id="ix_01_introduction-asciidoc5", range="startofrange")))The side effects of increasing the block size or decreasing the block time with respect to centralization of the network are severe, as a few calculations with the numbers show.

Let us assume the usage of Bitcoin grows so that the network has to process 40,000 transactions per second, which is the approximate transaction processing level of the Visa network during peak usage.

Assuming 250 bytes on average per transaction, this would result in a data stream of 10 megabytes per second (MBps) or 80 megabits per second (Mbps) just to be able to receive all the transactions.
This does not include the traffic overhead of forwarding the transaction information to other peers.
While 10 MBps does not seem extreme in the context of high-speed fiber optic and 5G mobile speeds, it would effectively exclude anyone who cannot meet this requirement from running a node, especially in countries where high-performance internet is not affordable or widely available.

Users also have many other demands on their bandwidth and cannot be expected to expend this much only to receive transactions.

Furthermore, storing this information locally would result in 864 gigabytes per day. This is roughly one terabyte of data, or the size of a hard drive.


Verifying 40,000 Elliptic Curve Digital Signature Algorithm (ECDSA) signatures per second is also barely feasible (see https://bitcoin.stackexchange.com/questions/95339/how-many-bitcoin-transactions-can-be-verified-per-second[this article on StackExchange]), making the _initial block download (IBD)_ of the Bitcoin blockchain  (synchronizing and verifying everything starting from the genesis block) almost impossible without very expensive hardware.

While 40,000 transactions per second seems like a lot, it only achieves parity with traditional financial payment networks at peak times. Innovations in machine-to-machine payments, microtransactions, and other applications are likely to push demand to many orders higher than that.

Simply put: you can't scale a blockchain to validate the entire world's transactions in a decentralized way.

_But what if each node wasn't required to know and validate every single transaction? What if there was a way to have scalable off-chain transactions, without losing the security of the Bitcoin network?_

In February 2015, Joseph Poon and Thaddeus Dryja proposed a possible solution to the Bitcoin scalability problem, with the publication of "The Bitcoin Lightning Network: Scalable Off-Chain Instant Payments."footnote:[Joseph Poon and Thaddeus Dryja. "The Bitcoin Lightning Network: Scalable Off-Chain Instant Payments." DRAFT Version 0.5.9.2. January 14, 2016. https://lightning.network/lightning-network-paper.pdf[].]

In the (now outdated) whitepaper, Poon and Dryja estimate that in order for Bitcoin to reach the 47,000 transactions per second processed at peak by Visa, it would require 8 GB blocks.
This would make running a node completely untenable for anyone but large-scale enterprises and industrial-grade operations.
The result would be a network in which only a few users could actually validate the state of the ledger.
Bitcoin relies on users validating the ledger for themselves, without explicitly trusting third parties, in order to stay decentralized.
Pricing users out of running nodes would force the average user to trust third parties to discover the state of the ledger, ultimately breaking the trust model of Bitcoin.

The Lightning Network proposes a new network, a second layer, where users can make payments to each other peer-to-peer, without the necessity of publishing a transaction to the Bitcoin blockchain for each payment.
Users may pay each other on the Lightning Network as many times as they want, without creating additional Bitcoin transactions or incurring on-chain fees.
They only make use of the Bitcoin blockchain to load bitcoin onto the Lightning Network initially and to _settle_, that is, to remove bitcoin from the Lightning Network.
The result is that many more Bitcoin payments can take place off-chain, with only the initial loading and final settlement transactions needing to be validated and stored by Bitcoin nodes.
Aside from reducing the burden on nodes, payments on the Lightning Network are cheaper for users because they do not need to pay blockchain fees, and more private for users because they are not published to all participants of the network and furthermore are not stored permanently.

While the Lightning Network was initially conceived for Bitcoin, it can be implemented on any blockchain that meets some basic technical requirements. Other blockchains, such as Litecoin, already support the Lightning Network. Additionally, several other blockchains are developing similar second layer or "layer 2" solutions to help them scale(((range="endofrange", startref="ix_01_introduction-asciidoc5")))(((range="endofrange", startref="ix_01_introduction-asciidoc4"))).(((range="endofrange", startref="ix_01_introduction-asciidoc3")))

=== The Lightning Network's Defining Features

((("Lightning Network (generally)","defining features")))The Lightning Network is a network that operates as a second layer protocol on top of Bitcoin and other blockchains. The Lightning Network enables fast, secure, private, trustless, and permissionless payments. Here are some of the features of the Lightning Network:

 * Users of the Lightning Network can route payments to each other for low cost and in real time.
 * Users who exchange value over the Lightning Network do not need to wait for block confirmations for payments.
 * Once a payment on the Lightning Network has completed, usually within a few seconds, it is final and cannot be reversed. Like a Bitcoin transaction, a payment on the Lightning Network can only be refunded by the recipient.
 * Whereas on-chain Bitcoin transactions are broadcast and verified by all nodes in the network, payments routed on the Lightning Network are transmitted between pairs of nodes and are not visible to everyone, resulting in much greater privacy.
 * Unlike transactions on the Bitcoin network, payments routed on the Lightning Network do not need to be stored permanently. Lightning thus uses fewer resources and hence is cheaper. This property also has benefits for privacy.
 * The Lightning Network uses onion routing, similar to the protocol used by The Onion Router (Tor) privacy network, so that even the nodes involved in routing a payment are only directly aware of their predecessor and successor in the payment route.
 * When used on top of Bitcoin, the Lightning Network uses real bitcoin, which is always in the possession (custody) and full control of the user. Lightning is not a separate token or coin, it _is_ Bitcoin.


[[user-stories]]
=== Lightning Network Use Cases, Users, and Their Stories

((("Lightning Network (generally)","use cases and users")))To better understand how the Lightning Network actually works, and why people use it, we'll be following a number of users and their stories.

In our examples, some of the people have already used Bitcoin and others are completely new to the Bitcoin network. Each person and their story, as listed here, illustrate one or more specific use cases. We'll be revisiting them throughout this book:

Consumer::
Alice is a Bitcoin user who wants to make fast, secure, cheap, and private payments for small retail purchases. She buys coffee with bitcoin, using the Lightning Network.

Merchant::
Bob owns a coffee shop, "Bob's Cafe." On-chain Bitcoin payments don't scale for small amounts like a cup of coffee, so he uses the Lightning Network to accept Bitcoin payments almost instantaneously and for low fees.

Software service business::
Chan is a Chinese entrepreneur who sells information services related to the Lightning Network, as well as Bitcoin and other cryptocurrencies. Chan is selling these information services over the internet by implementing micropayments over the Lightning Network. Additionally, Chan has implemented a liquidity provider service that rents inbound channel capacity on the Lightning Network, charging a small bitcoin fee for each rental period.

Gamer::
Dina is a teenage gamer from Russia. She plays many different computer games, but her favorite ones are those that have an "in-game economy" based on real money. As she plays games, she also earns money by acquiring and selling virtual in-game items. The Lightning Network allows her to transact in small amounts for in-game items as well as earn small amounts for completing quests.

=== Conclusion

In this chapter, we talked about the fundamental concept that underlies both Bitcoin and the Lightning Network: the fairness protocol.

We looked at the history of the Lightning Network and the motivations behind second layer scaling solutions for Bitcoin and other blockchain-based networks.

We learned basic terminology including node, payment channel, on-chain transactions, and off-chain payments.

Finally, we met Alice, Bob, Chan, and Dina, whom we'll be following throughout the rest of the book.(((range="endofrange", startref="ix_01_introduction-asciidoc0"))) In the next chapter, we'll meet Alice and walk through her thought process as she selects a Lightning wallet and prepares to make her first Lightning payment to buy a cup of coffee from Bob's Cafe.((("Bitcoin (system)","Lightning Network compared to", see="Bitcoin–Lightning Network comparisons")))((("channel", see="payment channel")))((("containers", see="Docker containers")))((("delivering payment", see="payment delivery")))((("DoS attacks", see="denial-of-service attacks")))((("encrypted message transport", see="Lightning encrypted transport protocol")))((("future issues", see="innovations in Lightning")))((("HTLCs", see="hash time-locked contracts")))((("invoices", see="Lightning invoices")))((("Lightning Network (generally)","Bitcoin compared to", see="Bitcoin–Lightning Network comparisons")))((("Lightning Network (generally)","invoices", see="Lightning invoices")))((("Lightning Network (generally)","network architecture", see="architecture, Lightning Network")))((("Lightning Network node", see="Lightning node entries")))((("Lightning payment requests", see="Lightning invoices")))((("LN node", see="Lightning node entries")))((("LND node project", see="Lightning Network Daemon node project")))((("message transport", see="Lightning encrypted transport protocol")))((("node", see="Lightning node entries")))((("payment channel","routing on network of", see="routing")))((("payment requests", see="Lightning invoices")))((("payment routing", see="routing")))((("privacy", see="breaches of privacy")))((("privacy", see="security and privacy")))((("private channels", see="unannounced channels")))((("TLV", see="Type-Length-Value")))((("wallet", see="Lightning wallet")))
